#  2024.2.18 Cpp学习记录（五）

## 一、数组

### （1）多维数组的初始化：

如果给出全部元素的初值，第一维的下标个数可以不用显式说明，例如：

`int a[2][3]={1,0,0,0,1,0};`

等价于

`int a[][3]={1,0,0,0,1,0};`

等价于

`int a[2][3]={{1,0,0},{0,1,0}};`

**声明为常量的数组必须给定初值**

### （2）对象数组

声明一个一维对象数组的语句形式：

`类名 数组名[常量表达式];`

每个数组元素都是一个对象，通过这个对象可以访问类的公有成员：

`数组名[下表表达式].成员名`

**初始化：**

`Location a[2]={Location{1,2},Location{3,4}};`

在数组初始化过程中调用形参类型相匹配的构造函数。

`Location a[2]={Location{1,2}};`

在执行时调用带形参的构造函数初始化`a[0]`，调用默认构造函数初始化`a[1]`。

## 二、指针

声明指针的语法形式：

`数据类型 *标识符;`

`cout<<*p;//输出指针p所指向的内容`

"*"出现在执行语句中或声明语句的初值表达式中作为一元运算符时，表示访问指针所指的对象的内容。

### （1）指针的赋值

在定义指针的同时进行初始化赋值，语法形式为：

`存储类型 数据类型 *指针名=初始地址;`

在定义之后，单独使用赋值语句，赋值语句的语法形式为：

`指针名=地址;`

数组名称实际上是一个不能被赋值的指针，即指针常量。

**指向常量的指针：**不能通过指针来改变所指对象的值，但指针本身可以改变，可以指向另外的对象。

```c++
int a;
const int *p1=&a;
int b;
p1=&b;
*p1=1;//错误
```

**指针类型的常量：**指针本身的值不能被改变。

```c++
int *const p2=&a;
p2=&b;//错误
```

**void类型指针：**可以存储任何类型的对象地址。经过显式类型转换，通过`void`类型的指针可以访问任何类型的数据。

```c++
void *pv;
int i=5;
pv=&i;
int *pint=static_cast<int *>(pv);
```

```c++
int *p;
p=0;//将p指针设置为空指针，不指向任何地址
```

### （2）用指针处理数组元素

**标准库函数begin和end：**

```c++
int a[10]={1,2,3,4,5,6,7,8,9,10};
int *beg=begin(a);
int *last=end(a);
```

`begin`函数返回指向数组a首元素的指针，`end`函数返回指向a尾元素下一位置的指针。

### （3）指针数组

声明一维指针数组的语法形式为：

`数据类型 *数组名[下标表达式];`

`array[i][j]等价于*(*(array+i)+j)`

### （4）指针型函数

指针型函数：函数的返回值是指针类型

```c++
数据类型  *函数名(参数)
{
	函数体;
}
```

```c++
typedef int arr[10];   //arr是一个类型别名，表示含有10个整数的数组
using arr=int[10];     //arr的等价声明
arr* foo(int i);       //foo返回一个指向含有10个整数的数组的指针
```

不使用类型别名：`类型说明符 (* 函数名(参数表)) [数组维度]`

```c++
int (* foo(int i))[10]

foo(int i)定义了一个函数foo，需要一个int类型的参数
(*foo(int))对函数的返回结果执行解析操作
(* foo(int i))[10]解析foo的返回结果得到的是一个大小为10的数组
int (* foo(int i))[10] 说明数组是int类型
```

`auto foo(int i) -> int(*)[10];` 声明了一个函数 `foo`，该函数接受一个整数参数，返回一个指针，该指针指向一个包含10个整数的数组。

### （5）指向函数的指针

一般语法：`数据类型 (* 函数指针名) (形参表)`

```c++
typedef int (* DoubleIntFunction)(double);  //声明DoubleIntFunction为有一个double形参、返回类型为int的函数的指针
DoubleIntFunction funcPtr;   //声明了一个具有该类型的名称为funcPtr的函数指针
```

初始化：

`函数指针名=函数名;`

### （6）对象指针

一般语法形式：`类名 * 对象指针名;`

使用对象指针可以访问对象的成员，语法形式为：

`对象指针名 -> 成员名`

### （7）this指针

this指针是成员函数的一个隐含形参，通过一个对象调用成员函数时，系统先将该对象的地址通过该参数传递给成员函数，成员函数对对象的数据成员进行操作时，就隐含使用了this指针。

this是一个指针常量，对于常成员函数，this同时又是一个指向常量的指针。

### （8）指向类的非静态成员的指针



## 三、字符串

将字符串常量赋给指向常量的指针：

`const char *STRING1="This is a string."`

**`getline()`函数：**输入字符串时只以换行符作为输入的分隔符。

`getline(cin,s2);`

`getline`允许在输入字符串时增加其他分隔符，使用方法是把可以作为分隔符的字符作为第3个参数传递给`getline`。

## 四、动态内存分配

`new`语法形式：`new 数据类型 (初始化参数列表);`

```c++
int *point;
point = int new(2);//赋值为2
```

不希望分配内存后设定初值：

```c++
int *point=new int;
```

若保留括号，但括号中不写任何数值，则表示用0对该对象初始化，如：

```c++
int *point=new int();
```

delete语法形式：`delete 指针名;`

`new`创建一维数组语法形式：`new 类型名 [数组长度];`

delete语法形式：`delete []指针名;`

`assert`用来判断一个条件表达式的值是否为true，若不为true，程序中止且报告错误

用`new`创建多维数组： `new 类型名 T[数组第1维长度][数组第2维长度][数组第3维长度]`

`new`运算返回一个指向新分配内存的首字节的指针，是一个指向T类型数组的指针，数组元素的个数为除最左边一维外各维下标表达式的乘积

```c++
float (*cp)[25][10];
cp=new float[10][25][10];
```

## 五、vector

`vector<元素类型>数组对象名{数组长度};`

用vector定义的数组对象的所有元素都会被初始化。

初值可以自己指定：

`vector<元素类型>数组对象名(数组长度，元素初值)`

`vector`数组对象的名字表示的就是一个数组对象，而非数组的首地址，因为数组对象不是数组，而是封装了数组的对象。